---
title: The Start-Upness is What You've Been Missing
layout: post
category: programming
published: false
---
After many in the IT industry seeking a job with satisfaction *and* security, I've finally come to the conclusion that you can simply never have both.  In fact, in our employee-hostile industry, the only way you can achieve even a marginal amount of security is by walling off a certain amount of business and systems knowledge, and refusing to share it.

<!-- read more -->

While this is clearly detrimental to the business and a gross violation of professional ethics, it is depressingly common.

I've spent a decade doing just about anything developer-related you can imagine.  The only common thread among every job I've had is that they were either for Big Business, or contract agencies trying to *act* like they were Big Business. (This is a terrible idea, by the way: it doesn't really net you any contracts worth having, and only saddles your small company with the unsustainable weight of big-company problems.)

About six months ago, I took a job at a startup.  This might seem like the acme of foolishness, since, with a mortgage and a new baby, job security and sustainability *should* have been foremost on my mind; however, I have had one too many traditional "secure" jobs evaporate around me to ever believe that long-term stability can ever be achieved unless you're willing to strong-arm the company you're working for.  Frankly, imagination fails me when trying to create a scenario in which I could even consider such a thing.  

Good programmers should always be trying to work themselves out of a job, not building nests of complexity to hide in.

While job security is always a factor, my next consideration is job satisfaction. (Money doesn't even really enter into the discussion.  Working for the money is like playing piano for the exercise.)  Job satisfaction, like obscenity, is hard to describe, but you'll know it when you see it.

Working for a startup has involved some culture shock.  The biggest difference is in productivity; it is through the roof.  My early estimates were grossly out of whack-- eyeballing items in our project, I would mentally assign a month or two to a feature, only to see it knocked out (including a test suite) in half a week.  This is not accomplished by the traditional approaches of piling on more hours (I have yet to work an 80-hour week), nor by high-pressure management tactics ("You'll be out of a job if this is not done in a month").  I've tried to 

On co-workers:
* Everyone around you knows what they're doing, and they all care about the quality of their work.
* Blame fingers stay firmly in everyone's respective pockets.  You don't realize how much a culture of blame exists in most jobs until you're out of it-- I spend far less time and stress covering myself (which is a tremendous benefit, since I've never been much good at it).

On Process:
* Simplicity is king.  YAGNI trumps scope creep. Scope stays narrow.  "Sudden" features bump other functionality out of the iteration.  Irrational expectations are corrected.
* Features are driven by management, but implementation is driven by developers.

On Management
* Management understands technology.  I don't have to spend hours justifying every technical decision.  I can explain and discuss, but defensiveness is unnecessary.  I'm not trying to communicate decades of process discovery and accepted best practices in every conversation.
* Management accepts developer estimates.  This doesn't necessarily mean they *like* the estimates, but they're willing to accept that the person with their fingers in the code has a better idea of how long something will take.  I haven't yet had to play the "guess the number I'm thinking of" game with management.  This has led to far less padding and higher accuracy.  It really is an incredible feeling to stick an estimate perfectly.
* Management accepts developer mistakes.  This doesn't necessarily mean they *like* the mistakes, but they're willing to accept that the person with their fingers in the code is going to screw up eventually.  I haven't yet had to play the "guess the punishment I'm thinking of" game with management.  This has led to far less backpedaling and higher morale.  It really is an incredible feeling to screw up and not have it wreck your whole weekend.

Some of these are things I have been (ineffectively) advocating, in various ways, for years.  It is indecently pleasant to be proven decisively correct on so many fronts.

These observations are neither shocking nor particularly insightful to someone who is accustomed to practicing agile development, but as someone who has spent the bulk of his career in corporate la-la land, I can state unequivocally that the difference is startling; looking back is like watching Luddites clinging stubbornly to their needles and thread while the poor run around naked.

A development model like this doesn't guarantee success-- the business world is famously unkind to startups, good, bad, and otherwise.  It also doesn't eliminate all development problems forever, leaving code monkeys to cartwheel through a candy-filled fantasyland.  People still make mistakes, priorities still get shuffled, and conflicts still crop up.  It does, however, keep engineers out of a bog of bad requirements, poor code, and despair, allowing them to focus on what good programmers naturally want to focus on: laying down quality code.

In a startup, there is always the natural concern about stability.  While it's 

